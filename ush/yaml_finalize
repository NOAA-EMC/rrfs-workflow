#!/usr/bin/env python
#
import os
import sys
#
def list_to_delimited_string(lst, spaces='  ', delimiter=', ', elements_per_line=20):
  # Convert the list to a comma-separated string with the specified delimiter
  joined_string = delimiter.join(map(str, lst))
  # Split the joined string into chunks of elements_per_line
  elements = joined_string.split(delimiter)
  # Create lines of up to elements_per_line elements
  lines = [delimiter.join(elements[i:i + elements_per_line]) for i in range(0, len(elements), elements_per_line)]
  # Add a comma at the end of each line except the last line
  formatted_lines = [spaces+line + delimiter.rstrip(' ') if i < len(lines) - 1 else spaces+line for i, line in enumerate(lines)]
  ###formatted_lines[0] = formatted_lines[0].lstrip(' ')
  return formatted_lines

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# get command line inputs
#
args = sys.argv
nargs = len(args)-1
if nargs < 1:
    print(f"{args[0]} [yaml_file]\n")
    exit()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# read the iuse information from convinfo for conventional observations
#
dcConvInfo  = {}
if os.path.exists('convinfo'):
  with open('convinfo','r') as sfile:
      for line in sfile:
          if not line.strip().startswith("!"):
              fields = line.split()
              if len(fields) == 9:
                  atype = fields[0]
                  if fields[1] != '0':
                      atype += fields[1].zfill(3)
                  if fields[2] != '0':
                      atype += "_" + fields[2].zfill(3)
                  #
                  dcTMP = {
                      'iuse': fields[3],
                      'twindow': fields[4],
                      'gross': fields[5],
                      'ermax': fields[6],
                      'ermin': fields[7],
                      'msgtype': fields[8],
                      }
                  dcConvInfo[atype] = dcTMP
              else:
                  print(f"read_convinfo Warning: expected 9 fields\n{line}")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# read satinfo
#
dcSatInfo  = {}
if os.path.exists('satinfo'):
    with open('satinfo','r') as sfile:
        for line in sfile:
            if not line.strip().startswith("!"):
                fields = line.split()
                if len(fields) == 11:
                    sis = fields[0]  #sensor/instr/sat
                    if sis in dcSatInfo:
                      dcSIS=dcSatInfo[sis]
                    else:
                      dcSIS = {'channel':[],'iuse':[],'error':[],'error_cld':[],'ermax':[],
                          'var_b':[],'var_pg':[],'icld_det':[],'icloud':[],'iaerosol':[],
                          }
                    #
                    dcSIS['channel'].append(fields[1])
                    dcSIS['iuse'].append(fields[2])
                    dcSIS['error'].append(fields[3])
                    dcSIS['error_cld'].append(fields[4])
                    dcSIS['ermax'].append(fields[5])
                    dcSIS['var_b'].append(fields[6])
                    dcSIS['var_pg'].append(fields[7])
                    dcSIS['icld_det'].append(fields[8])
                    dcSIS['icloud'].append(fields[9])
                    dcSIS['iaerosol'].append(fields[10])
                    dcSatInfo[sis]=dcSIS
                else:
                    print(f"read_satinfo warning: expected 11 fields\n{line}")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# generate the final use_obs list
#

# ~~~~~~~~~~~~~
# remove some atypes if conventional obs files not available
if dcConvInfo: # if non empty
    dcOBS={
        'ioda_adpupa.nc': ['t120','q120','ps120','uv220'],
        'ioda_aircar.nc': ['t133','q133','uv233'],
        }
    for iodafile, keys_to_remove in dcOBS.items():
        if not os.path.exists(f"data/obs/{iodafile}"):
            for key in keys_to_remove:
                dcConvInfo.pop(key,None) # `None` prevents KeyError if key doesn't exist
# ~~~~~~~~~~~~~
# remove some SIS if satellite obs files not available
if dcSatInfo: # if non empty
    dcOBS={
        'ioda_atms_npp.nc': ['atms_npp'],
        'ioda_cris-fsr_n20.nc': ['cris-fsr_n20'],
        }
    for iodafile, keys_to_remove in dcOBS.items():
        if not os.path.exists(f"data/obs/{iodafile}"):
            for key in keys_to_remove:
                dcSatInfo.pop(key,None) # `None` prevents KeyError if key doesn't exist

# ~~~~~~~~~~~~~
# assemble a final conventional obs use list
conv_list = []
for key,value in dcConvInfo.items():
    if value['iuse'] != "0":
        conv_list.append(key)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# if both conv_list and dcSatInfo are empty, print a warning message
#
if not conv_list and not dcSatInfo:
    print("WARNING: no convinfo/satinfo, empty/corrupt convinfo/satinfo or ioda files not available")
elif not conv_list:
    print("INFO: no convinfo, empty/corrupt convinfo, or conventional ioda files not available")
elif not dcSatInfo:
    print("INFO: no satinfo or empty/corrupt satinfo, or satellite ioda files not available")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# generate the yaml file on the fly
#
yfile = args[1]
basename = yfile.rstrip(".yaml")
yfile2 = basename + "_old001.yaml"
#
# find an available file name and backup the old yaml file
if os.path.exists(yfile2):
    knt=1
    yfile2 = f'{basename}_old{knt:03}.yaml'
    while os.path.exists(yfile2):
        knt += 1
        yfile2 = f'{basename}_old{knt:03}.yaml'
os.replace(yfile, yfile2)
#
with open(yfile2, 'r') as infile, open(yfile, 'w') as outfile:
    buffer_zone = []
    in_buffer_zone = False
    just_read_new_obs_space = False
    use_obs = False
    anchor_skip_old_values = False
    #
    for line in infile:
        if "obs space:" in line:
            # just read a new obs space, need to process buffer_zone
            if in_buffer_zone:
                # Write out the buffer zone if not moreve_obs
                if use_obs:
                    for buf_line in buffer_zone:
                        outfile.write(buf_line)
                # Reset buffer and state tracking
                buffer_zone = []
                in_buffer_zone = False
                use_obs = False
                anchor_skip_old_values = False
            #~~~~~
            just_read_new_obs_space = True
            in_buffer_zone = True
            buffer_zone.append(line)
        elif just_read_new_obs_space and "name" in line:
            just_read_new_obs_space = False
            buffer_zone.append(line)
            for obs in conv_list:
                if obs in line:
                    use_obs = True
                    break
            # ~~~~~~
            if not use_obs: # check whether it is a satellite observation
                for obs in dcSatInfo:
                    if obs in line:
                        use_obs = True
                        break

        elif "_anchor_" in line:
            if not use_obs:
                #print("found a sat anchor, but the SIS is not in 'satinfo' or empty/corrupt 'satinfo'")
                continue
            if "_anchor_channel:" in line:
                anchor_name = "channel"
            elif "_anchor_iuse:" in line:
                anchor_name = "iuse"
            elif "_anchor_error:" in line:
                anchor_name = "error"
            elif "_anchor_ermax:" in line:
                anchor_name = "ermax"
            elif "_anchor_icld_det:" in line:
                anchor_name = "icld_det"
            mysis = line.split('&')[1].strip().split('[')[0].strip()[:-len(f'{anchor_name}_')] # get the SIS id
            knt = line.find('&') + 1
            pre_spaces = ' ' * knt
            tmp_str = list_to_delimited_string(dcSatInfo[mysis][anchor_name], pre_spaces)
            new_str = '\n'.join(map(str, tmp_str))
            if f'&{mysis}_{anchor_name} [1]' in line: # simple template [1]
                line = line.replace(f'&{mysis}_{anchor_name} [1]', f'&{mysis}_{anchor_name} [\n{new_str}]').rstrip(' ')
            else:
                line = line.replace(f'&{mysis}_{anchor_name} [', f'&{mysis}_{anchor_name} [\n{new_str}]').rstrip(' ')
                anchor_skip_old_values = True
            buffer_zone.append(line)
        elif anchor_skip_old_values:
            if "distribution:" in line:
                anchor_skip_old_values = False
                buffer_zone.append(line)
        elif in_buffer_zone:
            buffer_zone.append(line)

        if not in_buffer_zone:
            outfile.write(line)
    #~~~~
    if buffer_zone:
        if use_obs:
            for buf_line in buffer_zone:
                outfile.write(buf_line)
# ~~~~~~~~
